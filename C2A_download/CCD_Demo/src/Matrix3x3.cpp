/*

Copyright (c) 2005 Gino van den Bergen / Erwin Coumans <www.erwincoumans.com>

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "math.h"
#include "Matrix3x3.h"
#include "def.h"
#include "assert.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

Matrix3x3::Matrix3x3()
{
	setValue(0, 0, 0, 0, 0, 0, 0, 0, 0);
}

Matrix3x3::Matrix3x3(const Quaternion& q)
{ 
	setRotation(q); 
}

Matrix3x3::Matrix3x3( const double& xx, const double& xy, const double& xz,
					  const double& yx, const double& yy, const double& yz,
					  const double& zx, const double& zy, const double& zz)
{ 
	setValue(xx, xy, xz, yx, yy, yz, zx, zy, zz);
}
	
Vector3D Matrix3x3::getColumn(int i)
{
	return Vector3D(e[0][i],e[1][i],e[2][i]);
}

void Matrix3x3::setColumn(int i, Vector3D v)
{
	e[0][i]=v[0];
	e[1][i]=v[1];
	e[2][i]=v[2];
}

Vector3D& Matrix3x3::getRow(int i)
{
	return e[i];
}

void Matrix3x3::setRow(int i, Vector3D v)
{
	e[i]=v;
}

Vector3D&  Matrix3x3::operator[](int i)
{ 
	assert(0 <= i && i < 3);
	return e[i]; 
}
		
Vector3D Matrix3x3::operator[](int i) const
{
	assert(0 <= i && i < 3);
	return e[i];
}
		
void Matrix3x3::setFromOpenGLSubMatrix(const double *m)
{
	e[0][0] = (m[0]); 
	e[1][0] = (m[1]); 
	e[2][0] = (m[2]);
	e[0][1] = (m[4]); 
	e[1][1] = (m[5]); 
	e[2][1] = (m[6]);
	e[0][2] = (m[8]); 
	e[1][2] = (m[9]); 
	e[2][2] = (m[10]);
}

void Matrix3x3::setValue( const double& xx, const double& xy, const double& xz, 
						  const double& yx, const double& yy, const double& yz, 
						  const double& zx, const double& zy, const double& zz)
{
	e[0][0] = double(xx); 
	e[0][1] = double(xy); 
	e[0][2] = double(xz);
	e[1][0] = double(yx); 
	e[1][1] = double(yy); 
	e[1][2] = double(yz);
	e[2][0] = double(zx); 
	e[2][1] = double(zy); 
	e[2][2] = double(zz);
}

void Matrix3x3::setRotation(const Quaternion& q) 
{
	double d = q.sqabs();
	assert(d != double(0.0));
	double s = double(2.0) / d;
	double xs = q[0] * s,   ys = q[1] * s,   zs = q[2] * s;
	double wx = q[3] * xs,  wy = q[3] * ys,  wz = q[3] * zs;
	double xx = q[0] * xs,  xy = q[0] * ys,  xz = q[0] * zs;
	double yy = q[1] * ys,  yz = q[1] * zs,  zz = q[2] * zs;
	setValue(double(1.0) - (yy + zz), xy - wz, xz + wy,
			 xy + wz, double(1.0) - (xx + zz), yz - wx,
			 xz - wy, yz + wx, double(1.0) - (xx + yy));
}
		
void Matrix3x3::setEulerYPR(const double& yaw, const double& pitch, const double& roll) 
{

	double  cy(cos(yaw)); 
	double  sy(sin(yaw)); 
	double  cp(cos(pitch)); 
	double  sp(sin(pitch)); 
	double  cr(cos(roll));
	double  sr(sin(roll));
	double  cc = cy * cr; 
	double  cs = cy * sr; 
	double  sc = sy * cr; 
	double  ss = sy * sr;
	setValue(cc - sp * ss, -cs - sp * sc, -sy * cp,
             cp * sr,       cp * cr,      -sp,
			 sc + sp * cs, -ss + sp * cc,  cy * cp);

}

void Matrix3x3::setEulerZYX(double eulerX,double eulerY,double eulerZ) 
{
	double ci ( cos(eulerX)); 
	double cj ( cos(eulerY)); 
	double ch ( cos(eulerZ)); 
	double si ( sin(eulerX)); 
	double sj ( sin(eulerY)); 
	double sh ( sin(eulerZ)); 
	double cc = ci * ch; 
	double cs = ci * sh; 
	double sc = si * ch; 
	double ss = si * sh;

	setValue(cj * ch, sj * sc - cs, sj * cc + ss,
			 cj * sh, sj * ss + cc, sj * cs - sc, 
	       		 -sj,      cj * si,      cj * ci);
}


void Matrix3x3::skewSymmetric(const Vector3D& v)
{
	setValue( 0.0,	-v.z,	 v.y, 
			  v.z,	 0.0,	-v.x, 
			 -v.y,	 v.x,	 0.0); 
	
}


void Matrix3x3::setIdentity()
{ 
	setValue(double(1.0), double(0.0), double(0.0), 
			 double(0.0), double(1.0), double(0.0), 
			 double(0.0), double(0.0), double(1.0)); 
}

void Matrix3x3::zero()
{ 
	setValue(double(0.0), double(0.0), double(0.0), 
			 double(0.0), double(0.0), double(0.0), 
			 double(0.0), double(0.0), double(0.0)); 
}

    
void Matrix3x3::getOpenGLSubMatrix(double *m) 
{
	m[0]  = double(e[0][0]); 
	m[1]  = double(e[1][0]);
	m[2]  = double(e[2][0]);
	m[3]  = double(0.0); 
	m[4]  = double(e[0][1]);
	m[5]  = double(e[1][1]);
	m[6]  = double(e[2][1]);
	m[7]  = double(0.0); 
	m[8]  = double(e[0][2]); 
	m[9]  = double(e[1][2]);
	m[10] = double(e[2][2]);
	m[11] = double(0.0); 
}

Quaternion Matrix3x3::getRotation()
{
	Quaternion q;
	double trace = e[0][0] + e[1][1] + e[2][2];
	
	if (trace > 0.0) 
	{
		double s = sqrt(trace + 1.0);
		q[3] = s * 0.5;
		s = 0.5 / s;
		
		q[0] = (e[2][1] - e[1][2]) * s;
		q[1] = (e[0][2] - e[2][0]) * s;
		q[2] = (e[1][0] - e[0][1]) * s;
	} 
	else 
	{
		int i = e[0][0] < e[1][1] ? 
			(e[1][1] < e[2][2] ? 2 : 1) :
			(e[0][0] < e[2][2] ? 2 : 0); 
		int j = (i + 1) % 3;  
		int k = (i + 2) % 3;
		
		double s = sqrt(e[i][i] - e[j][j] - e[k][k] + 1.0);
		q[i] = s * 0.5;
		s = 0.5 / s;
		
		q[3] = (e[k][j] - e[j][k]) * s;
		q[j] = (e[j][i] + e[i][j]) * s;
		q[k] = (e[k][i] + e[i][k]) * s;
	}

	return q;
}
/*
void Matrix3x3::getEuler(double& yaw, double& pitch, double& roll) const
{
	pitch = double(asin(-e[2][0]));
	if (pitch < SIMD_2_PI)
	{
		if (pitch > SIMD_2_PI)
		{
			yaw = double(atan2(e[1][0], e[0][0]));
			roll = double(atan2(e[2][1], e[2][2]));
		}
		else 
		{
			yaw = double(-atan2(-e[0][1], e[0][2]));
			roll = double(0.0);
		}
	}
	else
	{
		yaw = double(atan2(-e[0][1], e[0][2]));
		roll = double(0.0);
	}
}*/

Vector3D Matrix3x3::getScaling() const
{
	return Vector3D(e[0][0] * e[0][0] + e[1][0] * e[1][0] + e[2][0] * e[2][0],
				    e[0][1] * e[0][1] + e[1][1] * e[1][1] + e[2][1] * e[2][1],
				    e[0][2] * e[0][2] + e[1][2] * e[1][2] + e[2][2] * e[2][2]);
}


Matrix3x3 Matrix3x3::scaled(const Vector3D& s) const
{
	return Matrix3x3(e[0][0] * s[0], e[0][1] * s[1], e[0][2] * s[2],
							 e[1][0] * s[0], e[1][1] * s[1], e[1][2] * s[2],
							 e[2][0] * s[0], e[2][1] * s[1], e[2][2] * s[2]);
}

		
double Matrix3x3::tdot(int c, const Vector3D& v) const 
{
	return e[0][c] * v[0] + e[1][c] * v[1] + e[2][c] * v[2];
}
		
Matrix3x3 Matrix3x3::operator+(const Matrix3x3& m)
{
	Matrix3x3 matrix;
	matrix[0]= e[0] + m[0];
	matrix[1]= e[1] + m[1];
	matrix[2]= e[2] + m[2];
	return matrix;
}

Matrix3x3& Matrix3x3::operator+=(const Matrix3x3& m)
{
	e[0] += m[0];
	e[1] += m[1];
	e[2] += m[2];
	return *this;
}

Matrix3x3 Matrix3x3::operator-(const Matrix3x3& m)
{
	Matrix3x3 matrix;
	matrix[0]= e[0] - m[0];
	matrix[1]= e[1] - m[1];
	matrix[2]= e[2] - m[2];
	return matrix;
}

Matrix3x3& Matrix3x3::operator-=(const Matrix3x3& m)
{
	e[0] -= m[0];
	e[1] -= m[1];
	e[2] -= m[2];
	return *this;
}

Matrix3x3& 	Matrix3x3::operator*=(const Matrix3x3& m)
{
	setValue(m.tdot(0, e[0]), m.tdot(1, e[0]), m.tdot(2, e[0]),
			 m.tdot(0, e[1]), m.tdot(1, e[1]), m.tdot(2, e[1]),
			 m.tdot(0, e[2]), m.tdot(1, e[2]), m.tdot(2, e[2]));
	return *this;
}

Vector3D Matrix3x3::operator*(const Vector3D& v)
{
	return Vector3D(e[0].dot(v), e[1].dot(v), e[2].dot(v));
}

Matrix3x3 Matrix3x3::operator*(const double& d)
{
	return Matrix3x3(	e[0][0] *d, e[0][1] *d, e[0][2] *d, 
						e[1][0] *d, e[1][1] *d, e[1][2] *d, 
						e[2][0] *d, e[2][1] *d, e[2][2] *d);
}


double Matrix3x3::determinant() const
{ 
	return	e[0][0] * (e[1][1] * e[2][2] - e[1][2] * e[2][1]) + 
			e[0][1] * (e[1][2] * e[2][0] - e[1][0] * e[2][2]) +
			e[0][2] * (e[1][0] * e[2][1] - e[1][1] * e[2][0]);
}
	

Matrix3x3 Matrix3x3::abs() const
{
	return Matrix3x3(
		fabs(e[0][0]), fabs(e[0][1]), fabs(e[0][2]),
		fabs(e[1][0]), fabs(e[1][1]), fabs(e[1][2]),
		fabs(e[2][0]), fabs(e[2][1]), fabs(e[2][2]));
}

Matrix3x3 Matrix3x3::transpose() const 
{
	return Matrix3x3(e[0][0], e[1][0], e[2][0],
					 e[0][1], e[1][1], e[2][1],
					 e[0][2], e[1][2], e[2][2]);
}
	
Matrix3x3 Matrix3x3::adjoint() const 
{
	return Matrix3x3(cofac(1, 1, 2, 2), cofac(0, 2, 2, 1), cofac(0, 1, 1, 2),
							 cofac(1, 2, 2, 0), cofac(0, 0, 2, 2), cofac(0, 2, 1, 0),
							 cofac(1, 0, 2, 1), cofac(0, 1, 2, 0), cofac(0, 0, 1, 1));
}
	
Matrix3x3 Matrix3x3::inverse() const
{
	Vector3D co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));
	double det = (*this)[0].dot(co);
	assert(det != double(0.0f));
	double s = double(1.0f) / det;
	return Matrix3x3(co[0] * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,
					 co[1] * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,
					 co[2] * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);
}
	
Matrix3x3 Matrix3x3::transposeTimes(const Matrix3x3& m) const
{
	return Matrix3x3(
		e[0][0] * m[0][0] + e[1][0] * m[1][0] + e[2][0] * m[2][0],
		e[0][0] * m[0][1] + e[1][0] * m[1][1] + e[2][0] * m[2][1],
		e[0][0] * m[0][2] + e[1][0] * m[1][2] + e[2][0] * m[2][2],
		e[0][1] * m[0][0] + e[1][1] * m[1][0] + e[2][1] * m[2][0],
		e[0][1] * m[0][1] + e[1][1] * m[1][1] + e[2][1] * m[2][1],
		e[0][1] * m[0][2] + e[1][1] * m[1][2] + e[2][1] * m[2][2],
		e[0][2] * m[0][0] + e[1][2] * m[1][0] + e[2][2] * m[2][0],
		e[0][2] * m[0][1] + e[1][2] * m[1][1] + e[2][2] * m[2][1],
		e[0][2] * m[0][2] + e[1][2] * m[1][2] + e[2][2] * m[2][2]);
}

Matrix3x3 Matrix3x3::timesTranspose(Matrix3x3 m) const
{
	return Matrix3x3(
		m[0].dot(e[0]), m[0].dot(e[1]), m[0].dot(e[2]),
		m[1].dot(e[0]), m[1].dot(e[1]), m[1].dot(e[2]),
		m[2].dot(e[0]), m[2].dot(e[1]), m[2].dot(e[2]));
	
}

Matrix3x3& Matrix3x3::orthonormalize()
{
    Vector3D X=getColumn(0); 
    Vector3D Y=getColumn(1); 
    Vector3D Z;

    X.normalize();
    Z = X.cross(Y);    Z.normalize();
    Y = Z.cross(X);    Y.normalize();

	setColumn(0, X);
 	setColumn(1, Y);
 	setColumn(2, Z);

	return (*this);
}

Vector3D operator*(const Matrix3x3& m, const Vector3D& v) 
{
	return Vector3D(m[0].dot(v), m[1].dot(v), m[2].dot(v));
}


Vector3D operator*(const Vector3D& v, const Matrix3x3& m)
{
	return Vector3D(m.tdot(0, v), m.tdot(1, v), m.tdot(2, v));
}

Matrix3x3 operator*(const double& d, const Matrix3x3 m)
{
	return Matrix3x3(	m[0][0] *d, m[0][1] *d, m[0][2] *d, 
						m[1][0] *d, m[1][1] *d, m[1][2] *d, 
						m[2][0] *d, m[2][1] *d, m[2][2] *d);
}


Matrix3x3 operator*(const Matrix3x3& m1, const Matrix3x3& m2)
{
	return Matrix3x3(
		m2.tdot(0, m1[0]), m2.tdot(1, m1[0]), m2.tdot(2, m1[0]),
		m2.tdot(0, m1[1]), m2.tdot(1, m1[1]), m2.tdot(2, m1[1]),
		m2.tdot(0, m1[2]), m2.tdot(1, m1[2]), m2.tdot(2, m1[2]));
}


Matrix3x3 multTransposeLeft(const Matrix3x3& m1, const Matrix3x3& m2) 
{
	return Matrix3x3(
		m1[0][0] * m2[0][0] + m1[1][0] * m2[1][0] + m1[2][0] * m2[2][0],
		m1[0][0] * m2[0][1] + m1[1][0] * m2[1][1] + m1[2][0] * m2[2][1],
		m1[0][0] * m2[0][2] + m1[1][0] * m2[1][2] + m1[2][0] * m2[2][2],
		m1[0][1] * m2[0][0] + m1[1][1] * m2[1][0] + m1[2][1] * m2[2][0],
		m1[0][1] * m2[0][1] + m1[1][1] * m2[1][1] + m1[2][1] * m2[2][1],
		m1[0][1] * m2[0][2] + m1[1][1] * m2[1][2] + m1[2][1] * m2[2][2],
		m1[0][2] * m2[0][0] + m1[1][2] * m2[1][0] + m1[2][2] * m2[2][0],
		m1[0][2] * m2[0][1] + m1[1][2] * m2[1][1] + m1[2][2] * m2[2][1],
		m1[0][2] * m2[0][2] + m1[1][2] * m2[1][2] + m1[2][2] * m2[2][2]);
}


double Matrix3x3::cofac(int r1, int c1, int r2, int c2) const 
{
	return e[r1][c1] * e[r2][c2] - e[r1][c2] * e[r2][c1];
}

