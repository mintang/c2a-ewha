/*

Copyright (c) 2005 Gino van den Bergen / Erwin Coumans <www.erwincoumans.com>

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef MATRIX3X3_H
#define MATRIX3X3_H

//#include "Quaternion.h"


/** Defines a 3 x 3 matrix. Every element e[i] is a double. */
class Matrix3x3 {
public:
	/** Default constructor. Initializes each element to 0. */
	Matrix3x3 ();
	
	/** Set the matrix with a quaternion
		\param q The given quaternion	
	*/
	Matrix3x3(const Quaternion& q);

	/** Constructor. Initializes the elements to (xx, xy, xz,
												  yx, yy, yz,
												  zx, zy, zz). 
		\param xx The 00 element	
		\param xy The 01 element
		\param xz The 02 element
		\param yx The 10 element	
		\param yy The 11 element
		\param yz The 12 element
		\param zx The 20 element	
		\param zy The 21 element
		\param zz The 22 element
	*/
	Matrix3x3(const double& xx, const double& xy, const double& xz,
			  const double& yx, const double& yy, const double& yz,
			  const double& zx, const double& zy, const double& zz);
		
	/** Returns the ith column vector (depends on \a i). 
		\param i Specifies the ith column (0 for the first, 1 for the second, 2 for the third)
	*/
	Vector3D getColumn(int i);

	/** Set the ith column vector (depends on \a i). 
		\param i Specifies the ith column (0 for the first, 1 for the second, 2 for the third)
	*/
	void setColumn(int i, Vector3D v);

	/** Returns the ith row vector (depends on \a i). 
		\param i Specifies the ith row (0 for the first, 1 for the second, 2 for the third)
	*/
	Vector3D& getRow(int i);

	/** Set the ith row vector (depends on \a i). 
		\param i Specifies the ith row (0 for the first, 1 for the second, 2 for the third)
	*/
	void setRow(int i, Vector3D v);

	/** Returns the ith row vector (depends on \a i). 
		\param i Specifies the ith row (0 for the first, 1 for the second, 2 for the third)
	*/
	Vector3D&  operator[](int i);
	
	/** Returns the ith row vector (depends on \a i). 
		\param i Specifies the ith row (0 for the first, 1 for the second, 2 for the third)
	*/
	Vector3D operator[](int i) const;
	
	/** Set the elements with OpenGL matrix
		\param m The given OpenGL matrix	
	*/
	void setFromOpenGLSubMatrix(const double *m);


	/** Set the values of element to (xx, xy, xz,
									  yx, yy, yz,
									  zx, zy, zz). 
		\param xx The 00 element	
		\param xy The 01 element
		\param xz The 02 element
		\param yx The 10 element	
		\param yy The 11 element
		\param yz The 12 element
		\param zx The 20 element	
		\param zy The 21 element
		\param zz The 22 element
	*/
	void setValue(const double& xx, const double& xy, const double& xz, 
				  const double& yx, const double& yy, const double& yz, 
				  const double& zx, const double& zy, const double& zz);
  
	/** Set the matrix with a quaternion
		\param q The given quaternion	
	*/
	void setRotation(const Quaternion& q);
		
	/** Set the elements with three Euler angles
		\param yaw		The first angle	
		\param pitch	The second angle		
		\param roll		The third angle	
	*/
	void setEulerYPR(const double& yaw, const double& pitch, const double& roll);


	/** SetEulerZYX
	  \param euler a const reference to a Vector3D of euler angles
	  These angles are used to produce a rotation matrix. The euler
	  angles are applied in ZYX order. I.e a vector is first rotated 
	  about X then Y and then Z
	 */
	void setEulerZYX(double eulerX,double eulerY,double eulerZ);

	/** Set the identity matrix
	*/
	void setIdentity();

	/** Set the matrix a skew symmetric matrix
		\param v The given vector	
	*/
	void skewSymmetric(const Vector3D& v);

	/** Set the zero matrix
	*/
	void zero();

	/** Return the elements in the order of OpenGL matrix
		\param m The return OpenGL matrix	
	*/
	void getOpenGLSubMatrix(double *m);

	/** Convert and return a quaternion from the current matrix
		\param q The return quaternion	
	*/
	Quaternion getRotation();
	
	/** Convert and return euler angles from the current matrix
		\param yaw		The first angle	
		\param pitch 	The second angle		
		\param roll		The third angle	
	*/
	void getEuler(double& yaw, double& pitch, double& roll) const;

	/** Get the scaling of the current matrix
	*/
	Vector3D getScaling() const;
	
	/** Scale the matrix with the given vector
		\param s The given vector	
	*/
	Matrix3x3 scaled(const Vector3D& s) const;

	/** Add a given matrix
		\param m The given matrix	
	*/
	Matrix3x3 operator+(const Matrix3x3& m);

	/** Add a given matrix
		\param m The given matrix	
	*/
	Matrix3x3& operator+=(const Matrix3x3& m);

	/** Substract a given matrix
		\param m The given matrix	
	*/
	Matrix3x3 operator-(const Matrix3x3& m);

	/** Substract a given matrix
		\param m The given matrix	
	*/
	Matrix3x3& operator-=(const Matrix3x3& m);

	/** Multiply a given matrix
		\param m The given matrix	
	*/
	Matrix3x3& operator*=(const Matrix3x3& m);

	/** Multiply a given vector
		\param v The given vector	
	*/
	Vector3D& operator*=(const Vector3D& v);

	/** Multiply a given vector
		\param v The given vector	
	*/
	Vector3D operator*(const Vector3D& v);

	/** Multiply a given value
		\param d The given value	
	*/
	Matrix3x3 operator*(const double& d);

	/** Multiply a given matrix and a given vector
		\param m The given matrix	
		\param v The given vector	
	*/
	friend Vector3D operator*(const Matrix3x3& m, const Vector3D& v);

	/** Multiply a given vector and a given matrix
		\param v The given vector	
		\param m The given matrix	
	*/
	friend Vector3D operator*(const Vector3D& v, const Matrix3x3& m);

	/** Multiply a given value and a given matrix
		\param d The given value	
		\param m The given matrix	
	*/
	friend Matrix3x3 operator*(const double& d, const Matrix3x3 m);

	/** Multiply two matrix
		\param m1 The given first matrix	
		\param m2 The given second matrix	
	*/
	friend Matrix3x3 operator*(const Matrix3x3& m1, const Matrix3x3& m2);

	friend Matrix3x3 multTransposeLeft(const Matrix3x3& m1, const Matrix3x3& m2);

	/** Return the determinant of the current matrix
	*/
	double determinant() const;

	/** Return the adjoint matrix
	*/
	Matrix3x3 adjoint() const;

	/** Return the absolute of the matrix
	*/
	Matrix3x3 abs() const;

	/** Return the transpose of the matrix
	*/
	Matrix3x3 transpose() const;

	/** Return the inverse of the matrix
	*/
	Matrix3x3 inverse() const; 
	
	/** Return the transpose of the matrix which multiply a given matrix
	*/
	Matrix3x3 transposeTimes(const Matrix3x3& m) const;

	/** Return the transpose of the matrix which multiply a given matrix
	*/
	Matrix3x3 timesTranspose( Matrix3x3 m) const;
	
	/** Return the orthonornalized form of the current matrix
	*/
	Matrix3x3& orthonormalize();

	/** Return the value by multipy the cth column of the current matrix with the given vector
		\param c The cth column of the current matrix	
		\param v The given vector	
	*/
	double tdot(int c, const Vector3D& v) const;


private:
	double cofac(int r1, int c1, int r2, int c2) const;

	/** The element of matrix. three rows */
	Vector3D e[3];
};
	

#endif
